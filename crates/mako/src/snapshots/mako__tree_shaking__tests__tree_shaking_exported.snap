---
source: crates/mako/src/tree_shaking.rs
expression: content
---
const chunksIdToUrlMap = {};
chunksIdToUrlMap["./index.ts"] = `${"/"}index.js`;
chunksIdToUrlMap["./all_vendors"] = `${"/"}all_vendors-async.js`;
function createRuntime(makoModules, entryModuleId) {
    const modulesRegistry = {};
    function requireModule(moduleId) {
        if (modulesRegistry[moduleId] !== undefined) {
            return modulesRegistry[moduleId].exports;
        }
        const module = {
            id: moduleId,
            exports: {}
        };
        modulesRegistry[moduleId] = module;
        try {
            const execOptions = {
                id: moduleId,
                module,
                factory: makoModules[moduleId],
                require: requireModule
            };
            requireModule.i.forEach((interceptor)=>{
                interceptor(execOptions);
            });
            execOptions.factory(execOptions.module, execOptions.module.exports, execOptions.require);
        } catch (e) {
            console.error(`Error require module '${moduleId}':`, e);
            delete modulesRegistry[moduleId];
        }
        return module.exports;
    }
    requireModule.i = [];
    !(function() {
        let currentParents = [];
        let currentChildModule;
        const createHmrRequire = (require, moduleId)=>{
            const me = modulesRegistry[moduleId];
            if (!me) return require;
            const fn = (request)=>{
                if (me.hot.active) {
                    if (modulesRegistry[request]) {
                        const parents = modulesRegistry[request].parents;
                        if (!parents.includes(moduleId)) {
                            parents.push(moduleId);
                        }
                    } else {
                        currentParents = [
                            moduleId
                        ];
                        currentChildModule = request;
                    }
                    if (!me.children.includes(request)) {
                        me.children.push(request);
                    }
                } else {}
                return require(request);
            };
            Object.assign(fn, require);
            return fn;
        };
        const applyHotUpdate = (chunkId, update, runtime)=>{
            const { modules, removedModules } = update;
            const outdatedModules = [];
            for (const moduleId of Object.keys(modules)){
                if (!modulesRegistry[moduleId]) continue;
                if (outdatedModules.includes(moduleId)) continue;
                outdatedModules.push(moduleId);
                const queue = [
                    moduleId
                ];
                while(queue.length){
                    const item = queue.pop();
                    const module = modulesRegistry[item];
                    if (!module) continue;
                    if (module.hot._main) {
                        location.reload();
                    }
                    if (module.hot._selfAccepted) {
                        continue;
                    }
                    for (const parentModule of module.parents){
                        if (outdatedModules.includes(parentModule)) continue;
                        outdatedModules.push(parentModule);
                        queue.push(parentModule);
                    }
                }
            }
            const outdatedSelfAcceptedModules = [];
            for (const moduleId of outdatedModules){
                const module = modulesRegistry[moduleId];
                if (module.hot._selfAccepted) {
                    outdatedSelfAcceptedModules.push(module);
                }
            }
            for (const moduleId of outdatedModules){
                const module = modulesRegistry[moduleId];
                for (const handler of module.hot._disposeHandlers){
                    handler();
                }
                module.hot.active = false;
                delete modulesRegistry[moduleId];
                for (const childModule of module.children){
                    const child = modulesRegistry[childModule];
                    if (!child) continue;
                    const idx = child.parents.indexOf(moduleId);
                    if (idx !== -1) {
                        child.parents.splice(idx, 1);
                    }
                }
            }
            registerModules(modules);
            for (const module of outdatedSelfAcceptedModules){
                module.hot._requireSelf();
            }
            runtime(requireModule);
        };
        const createModuleHotObject = (moduleId, me)=>{
            const _main = currentChildModule !== moduleId;
            const hot = {
                _acceptedDependencies: {},
                _declinedDependencies: {},
                _selfAccepted: false,
                _selfDeclined: false,
                _selfInvalidated: false,
                _disposeHandlers: [],
                _requireSelf: function() {
                    currentParents = me.parents.slice();
                    currentChildModule = _main ? undefined : moduleId;
                    requireModule(moduleId);
                },
                _main,
                active: true,
                accept () {
                    this._selfAccepted = true;
                },
                dispose (callback) {
                    this._disposeHandlers.push(callback);
                },
                invalidate () {},
                check () {
                    const current_hash = requireModule.currentHash();
                    return fetch(`/${current_hash}.hot-update.json`).then((res)=>{
                        return res.json();
                    }).then((update)=>{
                        return Promise.all(update.c.map((chunk)=>{
                            let parts = chunk.split('.');
                            let l = parts.length;
                            let left = parts.slice(0, parts.length - 1).join('.');
                            let ext = parts[l - 1];
                            const hotChunkName = [
                                left,
                                current_hash,
                                'hot-update',
                                ext
                            ].join('.');
                            return new Promise((done)=>{
                                load(`/${hotChunkName}`, done);
                            });
                        }));
                    });
                },
                apply (update) {
                    return applyHotUpdate(update);
                }
            };
            currentChildModule = undefined;
            return hot;
        };
        requireModule.i.push((options)=>{
            const orginRequire = options.require;
            options.module.hot = createModuleHotObject(options.id, options.module);
            options.module.meta = {
                hot: options.module.hot
            };
            options.module.parents = currentParents;
            currentParents = [];
            options.module.children = [];
            options.require = createHmrRequire(options.require, options.id);
            options.require.currentHash = ()=>{
                return orginRequire._h;
            };
        });
        requireModule.applyHotUpdate = applyHotUpdate;
    })();
    const installedChunks = {};
    const ensure = (chunkId)=>{
        let data = installedChunks[chunkId];
        if (data === 0) return Promise.resolve();
        if (data) {
            return data[2];
        } else {
            const promise = new Promise((resolve, reject)=>{
                data = installedChunks[chunkId] = [
                    resolve,
                    reject
                ];
            });
            data[2] = promise;
            const url = chunksIdToUrlMap[chunkId];
            const error = new Error();
            const onLoadEnd = (event)=>{
                data = installedChunks[chunkId];
                if (data !== 0) installedChunks[chunkId] = undefined;
                if (data) {
                    const errorType = event?.type;
                    const src = event?.target?.src;
                    error.message = `Loading chunk ${chunkId} failed. (${errorType} : ${src})`;
                    error.name = 'ChunkLoadError';
                    error.type = errorType;
                    data[1](error);
                }
            };
            load(url, onLoadEnd, `chunk-${chunkId}`);
            return promise;
        }
    };
    const inProgress = {};
    const load = (url, done, key)=>{
        if (inProgress[url]) {
            return inProgress[url].push(done);
        }
        const script = document.createElement('script');
        script.timeout = 120;
        script.src = url;
        inProgress[url] = [
            done
        ];
        const onLoadEnd = (prev, event)=>{
            clearTimeout(timeout);
            const doneFns = inProgress[url];
            delete inProgress[url];
            script.parentNode?.removeChild(script);
            if (doneFns) {
                doneFns.forEach(function(fn) {
                    return fn(event);
                });
            }
            if (prev) return prev(event);
        };
        const timeout = setTimeout(onLoadEnd.bind(null, undefined, {
            type: 'timeout',
            target: script
        }), 120000);
        script.onerror = onLoadEnd.bind(null, script.onerror);
        script.onload = onLoadEnd.bind(null, script.onload);
        document.head.appendChild(script);
    };
    const jsonpCallback = (data)=>{
        const chunkIds = data[0];
        const modules = data[1];
        if (chunkIds.some((id)=>installedChunks[id] !== 0)) {
            registerModules(modules);
        }
        for (const id of chunkIds){
            if (installedChunks[id]) {
                installedChunks[id][0]();
            }
            installedChunks[id] = 0;
        }
    };
    const registerModules = (modules)=>{
        for(const id in modules){
            makoModules[id] = modules[id];
        }
    };
    requireModule._h = '12007938434137768300';
    requireModule.currentHash = ()=>{
        return requireModule._h;
    };
    requireModule.ensure = ensure;
    Promise.all([
        ensure("./all_vendors")
    ]).then(()=>{
        requireModule(entryModuleId);
    });
    return {
        requireModule,
        _modulesRegistry: modulesRegistry,
        _jsonpCallback: jsonpCallback,
        _makoModuleHotUpdate: requireModule.applyHotUpdate
    };
}
const runtime = createRuntime({
    "./1.ts": function(module, exports, require) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        function _export(target, all) {
            for(var name in all)Object.defineProperty(target, name, {
                enumerable: true,
                get: all[name]
            });
        }
        _export(exports, {
            foo2: function() {
                return foo;
            },
            bar2: function() {
                return /*#__UNUSED__*/ bar;
            }
        });
        function foo() {}
        const bar = 1;
    },
    "./index.ts": function(module, exports, require) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        var _1 = require("./1.ts");
        console.log(_1.foo2);
    }
}, './index.ts');
globalThis.jsonpCallback = runtime._jsonpCallback;
globalThis.modulesRegistry = runtime._modulesRegistry;
globalThis.makoModuleHotUpdate = runtime._makoModuleHotUpdate;

//# sourceMappingURL=index.js.map
