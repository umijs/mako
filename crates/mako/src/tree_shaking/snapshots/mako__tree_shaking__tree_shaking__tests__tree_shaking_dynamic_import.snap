---
source: crates/mako/src/tree_shaking/tree_shaking.rs
expression: content
---
var chunksIdToUrlMap = {
    "a.ts": "a_ts-async.js"
};
var cssChunksIdToUrlMap = {
    "a.ts": "a_ts-async.css"
};
var e = "index.ts";
var d = [];
var cssInstalledChunks = {
    "index.ts": 0
};
var m = {
    "index.ts": function(module, exports, require) {
        Promise.all([
            require.ensure("a.ts")
        ]).then(require.bind(require, "a.ts")).then((r)=>console.log(r));
    }
};
function createRuntime(makoModules, deps, entryModuleId) {
    const modulesRegistry = {};
    function requireModule(moduleId) {
        if (moduleId === '$$IGNORED$$') return {};
        const cachedModule = modulesRegistry[moduleId];
        if (cachedModule !== undefined) {
            if (cachedModule.error) {
                throw cachedModule.error;
            }
            return cachedModule.exports;
        }
        const module = {
            id: moduleId,
            exports: {}
        };
        modulesRegistry[moduleId] = module;
        try {
            const execOptions = {
                id: moduleId,
                module,
                factory: makoModules[moduleId],
                require: requireModule
            };
            requireModule.requireInterceptors.forEach((interceptor)=>{
                interceptor(execOptions);
            });
            execOptions.factory.call(execOptions.module.exports, execOptions.module, execOptions.module.exports, execOptions.require);
        } catch (e) {
            modulesRegistry[moduleId].error = e;
            throw e;
        }
        return module.exports;
    }
    requireModule.requireInterceptors = [];
    !(function() {
        requireModule.chunkEnsures = {};
        requireModule.ensure = function(chunkId) {
            return Promise.all(Object.keys(requireModule.chunkEnsures).reduce(function(promises, key) {
                requireModule.chunkEnsures[key](chunkId, promises);
                return promises;
            }, []));
        };
    })();
    !(function() {
        const installedChunks = (requireModule.jsonpInstalled = {});
        requireModule.chunkEnsures.jsonp = (chunkId, promises)=>{
            let data = installedChunks[chunkId];
            if (data === 0) return;
            if (data) {
                promises.push(data[2]);
            } else {
                const promise = new Promise((resolve, reject)=>{
                    data = installedChunks[chunkId] = [
                        resolve,
                        reject
                    ];
                });
                promises.push((data[2] = promise));
                const url = requireModule.publicPath + chunksIdToUrlMap[chunkId];
                const error = new Error();
                const onLoadEnd = (event)=>{
                    data = installedChunks[chunkId];
                    if (data !== 0) installedChunks[chunkId] = undefined;
                    if (data) {
                        const errorType = event?.type;
                        const src = event?.target?.src;
                        error.message = `Loading chunk ${chunkId} failed. (${errorType} : ${src})`;
                        error.name = 'ChunkLoadError';
                        error.type = errorType;
                        data[1](error);
                    }
                };
                requireModule.loadScript(url, onLoadEnd, `chunk-${chunkId}`);
                return promise;
            }
        };
    })();
    !(function() {
        const inProgress = {};
        requireModule.loadScript = (url, done, key)=>{
            if (inProgress[url]) {
                return inProgress[url].push(done);
            }
            const script = document.createElement('script');
            script.timeout = 120;
            script.src = url;
            inProgress[url] = [
                done
            ];
            const onLoadEnd = (prev, event)=>{
                clearTimeout(timeout);
                const doneFns = inProgress[url];
                delete inProgress[url];
                script.parentNode?.removeChild(script);
                if (doneFns) {
                    doneFns.forEach(function(fn) {
                        return fn(event);
                    });
                }
                if (prev) return prev(event);
            };
            const timeout = setTimeout(onLoadEnd.bind(null, undefined, {
                type: 'timeout',
                target: script
            }), 120000);
            script.onerror = onLoadEnd.bind(null, script.onerror);
            script.onload = onLoadEnd.bind(null, script.onload);
            document.head.appendChild(script);
        };
    })();
    !(function() {
        requireModule.cssInstalled = cssInstalledChunks;
        requireModule.findStylesheet = function(url) {
            return Array.from(document.querySelectorAll('link[href][rel=stylesheet]')).find((link)=>{
                const [linkUrl] = link.getAttribute('href').split('?');
                return linkUrl === url || linkUrl === requireModule.publicPath + url;
            });
        };
        requireModule.createStylesheet = function(chunkId, url, oldTag, resolve, reject) {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = url;
            link.onerror = link.onload = function(event) {
                link.onerror = link.onload = null;
                if (event.type === 'load') {
                    cssInstalledChunks[chunkId] = 0;
                    resolve();
                } else {
                    delete cssInstalledChunks[chunkId];
                    const errorType = event?.type;
                    const realHref = event?.target?.href;
                    const err = new Error('Loading CSS chunk ' + chunkId + ' failed.\n(' + realHref + ')');
                    err.code = 'CSS_CHUNK_LOAD_FAILED';
                    err.type = errorType;
                    err.request = realHref;
                    link.parentNode.removeChild(link);
                    reject(err);
                }
            };
            if (oldTag) {
                oldTag.parentNode.insertBefore(link, oldTag.nextSibling);
            } else {
                document.head.appendChild(link);
            }
            return link;
        };
        requireModule.chunkEnsures.css = (chunkId, promises)=>{
            if (cssInstalledChunks[chunkId]) {
                promises.push(cssInstalledChunks[chunkId]);
            } else if (cssInstalledChunks[chunkId] !== 0 && cssChunksIdToUrlMap[chunkId]) {
                cssInstalledChunks[chunkId] = new Promise((resolve, reject)=>{
                    const url = cssChunksIdToUrlMap[chunkId];
                    const fullUrl = requireModule.publicPath + url;
                    if (requireModule.findStylesheet(url)) {
                        resolve();
                    } else {
                        requireModule.createStylesheet(chunkId, fullUrl, null, resolve, reject);
                    }
                });
                promises.push(cssInstalledChunks[chunkId]);
                return promises;
            }
        };
    })();
    const jsonpCallback = (data)=>{
        const installedChunks = requireModule.jsonpInstalled;
        const chunkIds = data[0];
        const modules = data[1];
        if (chunkIds.some((id)=>installedChunks[id] !== 0)) {
            registerModules(modules);
        }
        for (const id of chunkIds){
            if (installedChunks[id]) {
                installedChunks[id][0]();
            }
            installedChunks[id] = 0;
        }
    };
    const registerModules = (modules)=>{
        for(const id in modules){
            makoModules[id] = modules[id];
        }
    };
    requireModule._h = '1837553140176882911';
    requireModule.currentHash = ()=>{
        return requireModule._h;
    };
    !function() {
        requireModule.publicPath = "/";
    }();
    !function() {
        registerModules({
            "@swc/helpers/_/_interop_require_default": function(module, exports, require) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                function _export(target, all) {
                    for(var name in all)Object.defineProperty(target, name, {
                        enumerable: true,
                        get: all[name]
                    });
                }
                _export(exports, {
                    _interop_require_default: function() {
                        return _interop_require_default;
                    },
                    _: function() {
                        return _interop_require_default;
                    }
                });
                function _interop_require_default(obj) {
                    return obj && obj.__esModule ? obj : {
                        default: obj
                    };
                }
            },
            "@swc/helpers/_/_interop_require_wildcard": function(module, exports, require) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                function _export(target, all) {
                    for(var name in all)Object.defineProperty(target, name, {
                        enumerable: true,
                        get: all[name]
                    });
                }
                _export(exports, {
                    _interop_require_wildcard: function() {
                        return _interop_require_wildcard;
                    },
                    _: function() {
                        return _interop_require_wildcard;
                    }
                });
                function _getRequireWildcardCache(nodeInterop) {
                    if (typeof WeakMap !== "function") return null;
                    var cacheBabelInterop = new WeakMap();
                    var cacheNodeInterop = new WeakMap();
                    return (_getRequireWildcardCache = function(nodeInterop) {
                        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
                    })(nodeInterop);
                }
                function _interop_require_wildcard(obj, nodeInterop) {
                    if (!nodeInterop && obj && obj.__esModule) return obj;
                    if (obj === null || typeof obj !== "object" && typeof obj !== "function") return {
                        default: obj
                    };
                    var cache = _getRequireWildcardCache(nodeInterop);
                    if (cache && cache.has(obj)) return cache.get(obj);
                    var newObj = {};
                    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                    for(var key in obj){
                        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);
                            else newObj[key] = obj[key];
                        }
                    }
                    newObj.default = obj;
                    if (cache) cache.set(obj, newObj);
                    return newObj;
                }
            },
            "@swc/helpers/_/_export_star": function(module, exports, require) {
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                function _export(target, all) {
                    for(var name in all)Object.defineProperty(target, name, {
                        enumerable: true,
                        get: all[name]
                    });
                }
                _export(exports, {
                    _export_star: function() {
                        return _export_star;
                    },
                    _: function() {
                        return _export_star;
                    }
                });
                function _export_star(from, to) {
                    Object.keys(from).forEach(function(k) {
                        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
                            Object.defineProperty(to, k, {
                                enumerable: true,
                                get: function() {
                                    return from[k];
                                }
                            });
                        }
                    });
                    return from;
                }
            }
        });
    }();
    !(function() {
        let currentParents = [];
        let currentChildModule;
        requireModule.hmrC = {};
        const createHmrRequire = (require, moduleId)=>{
            const me = modulesRegistry[moduleId];
            if (!me) return require;
            const fn = (request)=>{
                if (me.hot.active) {
                    if (modulesRegistry[request]) {
                        const parents = modulesRegistry[request].parents;
                        if (!parents.includes(moduleId)) {
                            parents.push(moduleId);
                        }
                    } else {
                        currentParents = [
                            moduleId
                        ];
                        currentChildModule = request;
                    }
                    if (!me.children.includes(request)) {
                        me.children.push(request);
                    }
                } else {}
                return require(request);
            };
            Object.assign(fn, require);
            return fn;
        };
        const applyHotUpdate = (_chunkId, update)=>{
            const { modules, removedModules } = update;
            const outdatedModules = [];
            for (const moduleId of Object.keys(modules)){
                if (!modulesRegistry[moduleId]) continue;
                if (outdatedModules.includes(moduleId)) continue;
                outdatedModules.push(moduleId);
                const queue = [
                    moduleId
                ];
                while(queue.length){
                    const item = queue.pop();
                    const module = modulesRegistry[item];
                    if (!module) continue;
                    if (module.hot._main) {
                        location.reload();
                    }
                    if (module.hot._selfAccepted) {
                        continue;
                    }
                    for (const parentModule of module.parents){
                        if (outdatedModules.includes(parentModule)) continue;
                        outdatedModules.push(parentModule);
                        queue.push(parentModule);
                    }
                }
            }
            const outdatedSelfAcceptedModules = [];
            for (const moduleId of outdatedModules){
                const module = modulesRegistry[moduleId];
                if (module.hot._selfAccepted) {
                    outdatedSelfAcceptedModules.push(module);
                }
            }
            for (const moduleId of outdatedModules){
                const module = modulesRegistry[moduleId];
                for (const handler of module.hot._disposeHandlers){
                    handler();
                }
                module.hot.active = false;
                delete modulesRegistry[moduleId];
                for (const childModule of module.children){
                    const child = modulesRegistry[childModule];
                    if (!child) continue;
                    const idx = child.parents.indexOf(moduleId);
                    if (idx !== -1) {
                        child.parents.splice(idx, 1);
                    }
                }
            }
            registerModules(modules);
            for (const module of outdatedSelfAcceptedModules){
                module.hot._requireSelf();
            }
        };
        const createModuleHotObject = (moduleId, me)=>{
            const _main = currentChildModule !== moduleId;
            const hot = {
                _acceptedDependencies: {},
                _declinedDependencies: {},
                _selfAccepted: false,
                _selfDeclined: false,
                _selfInvalidated: false,
                _disposeHandlers: [],
                _requireSelf: function() {
                    currentParents = me.parents.slice();
                    currentChildModule = _main ? undefined : moduleId;
                    requireModule(moduleId);
                },
                _main,
                active: true,
                accept () {
                    this._selfAccepted = true;
                },
                dispose (callback) {
                    this._disposeHandlers.push(callback);
                },
                invalidate () {},
                check () {
                    const current_hash = requireModule.currentHash();
                    return fetch(`${requireModule.publicPath}${current_hash}.hot-update.json`).then((res)=>{
                        return res.json();
                    }).then((update)=>{
                        return Promise.all(update.c.map((chunk)=>{
                            let parts = chunk.split('.');
                            let l = parts.length;
                            let left = parts.slice(0, parts.length - 1).join('.');
                            let ext = parts[l - 1];
                            const hotChunkName = [
                                left,
                                current_hash,
                                'hot-update',
                                ext
                            ].join('.');
                            return new Promise((done)=>{
                                const url = `${requireModule.publicPath}${hotChunkName}`;
                                requireModule.loadScript(url, done);
                            });
                        }));
                    });
                },
                apply (update) {
                    return applyHotUpdate(update);
                }
            };
            currentChildModule = undefined;
            return hot;
        };
        requireModule.hmrC.jsonp = (chunkId, update, promises)=>{
            promises.push(new Promise((resolve)=>{
                applyHotUpdate(chunkId, update);
                resolve();
            }));
        };
        requireModule.hmrC.css = (chunkId, _update, promises)=>{
            if (cssChunksIdToUrlMap[chunkId]) {
                promises.push(new Promise((resolve, reject)=>{
                    let url = cssChunksIdToUrlMap[chunkId];
                    const fullUrl = requireModule.publicPath + url;
                    const oldLink = requireModule.findStylesheet(url);
                    if (oldLink) {
                        const newLink = requireModule.createStylesheet(chunkId, `${fullUrl}?${Date.now()}`, oldLink, ()=>{
                            newLink.rel = 'stylesheet';
                            newLink.as = null;
                            oldLink.parentNode.removeChild(oldLink);
                            resolve();
                        }, reject);
                        newLink.rel = 'prereload';
                        newLink.as = 'style';
                    }
                }));
            }
        };
        requireModule.requireInterceptors.push((options)=>{
            const orginRequire = options.require;
            options.module.hot = createModuleHotObject(options.id, options.module);
            options.module.meta = {
                hot: options.module.hot
            };
            options.module.parents = currentParents;
            currentParents = [];
            options.module.children = [];
            options.require = createHmrRequire(options.require, options.id);
            options.require.currentHash = ()=>{
                return orginRequire._h;
            };
        });
        requireModule.applyHotUpdate = (chunkId, update, runtime)=>{
            runtime(requireModule);
            return Promise.all(Object.keys(requireModule.hmrC).reduce(function(promises, key) {
                requireModule.hmrC[key](chunkId, update, promises);
                return promises;
            }, []));
        };
    })();
    let exports = null;
    if (deps.length > 0) {
        exports = Promise.all(deps.map(function(dep) {
            return requireModule.ensure(dep);
        })).then(function() {
            return requireModule(entryModuleId);
        });
    } else {
        exports = requireModule(entryModuleId);
    }
    return {
        exports,
        requireModule,
        _modulesRegistry: modulesRegistry,
        _jsonpCallback: jsonpCallback,
        _makoModuleHotUpdate: requireModule.applyHotUpdate
    };
}
const runtime = createRuntime(m, d, e);
(typeof globalThis !== 'undefined' ? globalThis : self).jsonpCallback = runtime._jsonpCallback;
(typeof globalThis !== 'undefined' ? globalThis : self).modulesRegistry = runtime._modulesRegistry;
(typeof globalThis !== 'undefined' ? globalThis : self).makoModuleHotUpdate = runtime._makoModuleHotUpdate;

//# sourceMappingURL=index.js.map
